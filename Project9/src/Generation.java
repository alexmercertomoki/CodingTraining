/* Generated by Together */
import java.util.*;
import java.text.*;

/** A container of GPTrees. */
public class Generation {
    private int numTrees;
    private GPTree[] population;
    private double[] fitness;

    /** Specifies the number of GPTrees in this generation, the
    * factories used to generate the individual trees, the maximum tree depth,
    * and the Random object used. */
    Generation(int numTrees, OperatorFactory o, TerminalFactory t, int m, Random r) {
        this.numTrees = numTrees;
        population = new GPTree[numTrees];
        for (int i = 0; i < numTrees; i++)
            population[i] = new GPTree(o, t, m, r);
    }

    /** Evaluate each tree in this generation, and set each tree's fitness value. */
    public void evalAll(DataSet d) {
    	
    	 double[] fitnessTemp=new double[numTrees]; 
    
        for (int i = 0; i < numTrees; i++)
        	
        	// here we get 1/fitness not the original fitness for choosing better   // why null!!!!!!!!!!!!!!!!!
        	fitnessTemp[i]=  population[i].eval(d);
          
            this.setFitness(fitnessTemp);
        //    System.out.println(fitness);
        
    }

    public double[] getFitness() {
		return fitness;
	}

	public void setFitness(double[] fitness) {
		this.fitness = fitness;
	}

	/** Print the symbolicEval of each tree, and its fitness value. Very lengthy! */
    public void printAll() {
        for (int i = 0; i < numTrees; i++) {
            System.out.println(population[i]);
            System.out.println("This tree's fitness is "
                +  NumberFormat.getInstance().format(population[i].getFitness()));
        }
    }

    /** Prints the tree with the lowest fitness value. */
    public void printBestTree() {
        Arrays.sort(population);
             //printAll();
	         System.out.println(population[0]);
             System.out.println("Best! fitness is " + population[0].getFitness());
    }
    
    public GPTree chooseTreeProportionalToFitness(){
    	
    	// System.out.println(fitness);
    	 //this is to store the total value of tree fitness
    	 double sum = 0;
    	 // the segment points for each tree
    	 double[] sumIndividual =new double[numTrees];
    	
    	
    	 
    	 //to hold the random number ranging from  
    	 
    	 double ChooseFit=0;
    	 //adding all fitness together to get the sum 
    	 for(int i=0;i<numTrees;i++)
    	 {  
    		sum += fitness[i];
    		//each segment point
    		sumIndividual[i]=sum;
    		
    	 }
    	// System.out.println(sum);
    	 // get the random number between the region
    	 ChooseFit= Math.random()*sum;
    	 
    	 // choosing the period
    	 for(int i=0;i<numTrees;i++)
    	 {       
    		    //if it's the first tree we get from 0 to the first boundary
    		    if(i==0){
    		    	if(sumIndividual[i]>= ChooseFit && ChooseFit>=0){
    		    		//return the population
    		    		return  population[i];
    		    	}	
    		    		
    		    }
    		    
    		    //else we get the value from  the last boudary to this boundary
    			if(sumIndividual[i]> ChooseFit && ChooseFit>=sumIndividual[i-1]){
    				//return the population 
    				return population[i];
    			}
    	
    	 }
		return null;
    	 
    }
    
   //getters and setters for generation
	public GPTree[] getPopulation() {
		return population;
	}

	public void setPopulation(GPTree[] population) {
		this.population = population;
	}
}
